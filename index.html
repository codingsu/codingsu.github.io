<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="SJW, Blog" />










<meta property="og:type" content="website">
<meta property="og:title" content="sjw_blog">
<meta property="og:url" content="https://codingsu.github.io/index.html">
<meta property="og:site_name" content="sjw_blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sjw_blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://codingsu.github.io/"/>





  <title>sjw_blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">sjw_blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://codingsu.github.io/2018/03/26/reversestack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sujunwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sjw_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/26/reversestack/" itemprop="url">如何仅用递归函数和栈操作逆序一个栈</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T16:50:49+08:00">
                2018-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一个栈一次压入1、2、3、4、5，那么从栈顶到栈底分别为5、4、3、2、1.将这个栈转置后，从栈顶到栈底为1、2、3、4、5，也就是实现栈中元素的逆序，但是只能用递归函数来实现，不能用其他数据结构。</p>
<p><strong>解题思路</strong></p>
<p>本题考查栈的操作和递归函数的设计，需要设计两个递归函数。<br>函数一：将栈stack的栈底元素返回并移除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAndRemoveLastElement</span><span class="params">(Stack&lt;Integer&gt; stack)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> last = getAndRemoveLastElement(stack);</span><br><span class="line">            stack.push(result);</span><br><span class="line">            <span class="keyword">return</span> last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="fun1.png" alt="fun1"></p>
<p>函数二：逆序一个栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(Stack&lt;Integer&gt; stack)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = getAndRemoveLastElement(stack);</span><br><span class="line">        reverse(stack);</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="fun2.png" alt="fun2"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://codingsu.github.io/2018/03/26/Spark-study-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sujunwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sjw_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/26/Spark-study-7/" itemprop="url">Spark-study-7</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T10:18:48+08:00">
                2018-03-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://codingsu.github.io/2018/03/26/Spark-study-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sujunwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sjw_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/26/Spark-study-6/" itemprop="url">Spark学习笔记(6) —— 容错和HA</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T09:41:47+08:00">
                2018-03-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spark学习笔记-6-——-容错和HA"><a href="#Spark学习笔记-6-——-容错和HA" class="headerlink" title="Spark学习笔记(6) —— 容错和HA"></a>Spark学习笔记(6) —— 容错和HA</h1><p>所谓容错是指一个系统的部分出现错误的情况还能够持续地提供服务，不会因为一些细微的错误导致系统性能严重下降或者出现系统瘫痪。在一个集群出现机器故障、网络问题等是常态，尤其集群达到较大规模后，很可能较频繁出现机器故障不能进行提供服务，因此对于分布式集群需要进行容错设计。</p>
<p><strong>Executor异常</strong></p>
<p>Spark支持多种运行模式，这些运行模式中的集群管理器会为任务分配运行资源，在运行资源中启动Executor，由Executor是负责执行任务的运行，最终把任务运行状态发送给Driver。下面以独立运行模式分析Executor出现异常的情况。</p>
<p><img src="spark1.png" alt="Executor异常容错过程图"></p>
<ol>
<li>首先看Executor的启动过程：在集群中由Master给应用程序分配资源后，然后在Worker中启动ExecutorRunner，而ExecutorRunner根据当前的运行模式启动CoarseGrainedExecutorBackend进程，当改进程会向Driver发送注册Executor信息，如果注册成功，则在其内部启动Executor。Executor由ExecutorRunner进行管理，当Executor出现异常时，由ExecutorRunner捕获该异常并发送ExecutorStateChanged消息给Worker。</li>
<li>Worker接收到ExecutorStateChanged消息时，在Worker的handleExecutorStateChanged方法中，根据Executor状态进行信息更新，同时把Executor状态信息转发给Master。</li>
<li>Master接收到Executor状态变换消息后，如果发现Executor出现异常退出，则调用Master schedule方法，尝试获取可用的Worker节点并启动Executor，而这个Worker很可能不是失败之前运行Executor的Worker节点。该尝试系统会进行10次，如果超过10次，则标记改应用运行失败并移除，集群中也移除该应用。</li>
</ol>
<p><strong>Worker异常</strong></p>
<p>Spark独立运行模式才有的是Master/Slave的结构，其中Slave是有Worker来担任的，在运行的时候会发送信条给Master，让Master知道Worker的试试状态，另一方面Master也会检测注册的Worker是否超时，因为在集群运行过程中，可能由于机器宕机或者进程被杀死等原因造成Worker进程异常退出。</p>
<p><img src="spark2.png" alt="work异常检测"></p>
<p>当Worker初心超时时，Master调用timeOutDeadWorkers方法进行处理，在处理时根据Worker运行的是Executor和Driver处理。</p>
<ul>
<li>如果是Executor，Master先把改Worker上运行的Executer发送消息ExecutorUpdated给对应的Driver，告知Executor已经丢失，同时把这些Executor从其应用程序运行列表中删除。另外，相关Executor的异常也需要按照之前Executor异常处理。</li>
<li>如果是Driver，则判断是否设置重新启动。如果需要重新启动，则调用Master.schedule方法进行调度，分配合适节点重启Driver；如果不需要重启，则删除该应用程序。</li>
</ul>
<p><strong>Master异常</strong></p>
<p>Master作为Spark独立运行模式中的核心，如果Master出现异常，则整个集群的运行情况和资源将无法进行管理。Spark在集群运行的时候，Master将启动一个或多个Standby Master，当Master出现异常的时候，Standby Master将根据一定规则确定其中一个接管Master。在独立运行模式中，Spark支持如下几种策略：</p>
<ul>
<li>ZOOKEEPER：集群的元数据持久化到ZooKeeper中，当Master出现异常时，ZooKeeper会通过选举机制选举出新的Master，新的Master接管时需要从ZooKeeper获取持久化信息并根据这些信息回复集群状态。</li>
<li>FILESYSTEM：集群的元数据持久化到本地文件系统中，当Master出现异常时，只要在该机器上重新启动Master，启动后新的Master获取持久化信息并根据这些信息回复集群状态。</li>
<li>CUSTOM：自定义回复方式。</li>
<li>NONE：不持久化集群的元数据，当Master出现异常时，新启动的Master不进行恢复集群状态，而是直接接管集群。</li>
</ul>
<p><img src="spark2.png" alt="Master异常容错"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://codingsu.github.io/2018/03/25/Spark-study-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sujunwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sjw_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/25/Spark-study-5/" itemprop="url">Spark学习笔记(5) —— 调度算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-25T14:58:13+08:00">
                2018-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spark/" itemprop="url" rel="index">
                    <span itemprop="name">spark</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spark学习笔记-5-——-调度算法"><a href="#Spark学习笔记-5-——-调度算法" class="headerlink" title="Spark学习笔记(5) —— 调度算法"></a>Spark学习笔记(5) —— 调度算法</h1><h4 id="应用程序之间"><a href="#应用程序之间" class="headerlink" title="应用程序之间"></a>应用程序之间</h4><p>ClusterManager提供了资源的分配和管理，而在独立运行模式中Master提供了资源管理调度功能。在调度过程中，Master先启动等待列表中应用程序的Driver，这些Driver尽可能分散在集群的Worker节点上，然后根据集群的内存和CPU使用情况，对等待的应用程序进行资源分配，在分配算法上根据先来先分配，先分配的应用程序会尽可能地获取满足条件的资源，后分配的应用程序只能在剩余资源中再次筛选。如果没有合适资源的应用程序只能等待，知道其他应用程序释放。该侧率可以认为是有条件的FIFO策略。</p>
<h4 id="作业与调度阶段之间"><a href="#作业与调度阶段之间" class="headerlink" title="作业与调度阶段之间"></a>作业与调度阶段之间</h4><p>Spark应用程序提交执行时，会根据RDD依赖关系形成有向无环图(DAG)，然后交给DAGScheduler进行划分作业和调度阶段。这些作业之间可以没有任何依赖关系，对于多个作业之间的调度，Spark目前提供了两种调度策略：一种是FIFO模式，这也是目前默认的模式；另一种是FAIR模式，该模式的调度可以通过两个参数的配置来决定Job执行的邮箱模式。</p>
<p>在FAIR算法中，现货区两个调度的饥饿成都，饥饿程度为正在运行的任务是否小于最小任务，如果是，则表示该调度处于饥饿成都。获取饥饿程度后进行如下比较：</p>
<ul>
<li>如果某个调度处于饥饿状态另外一个非饥饿状态，则先满足处于饥饿状态的调度；</li>
<li>如果两个调度都处于饥饿状态，则比较资源比，先满足资源比小的调度；</li>
<li>如果两个调度都出与非饥饿状态，则比较权重比，先满足权重比小的调度；</li>
<li>以上情况均相同的情况，根据调度的名称排序。</li>
</ul>
<h4 id="任务之间"><a href="#任务之间" class="headerlink" title="任务之间"></a>任务之间</h4><p><strong>数据本地性</strong></p>
<p>数据的计算尽可能在数据所在节点上进行，这样可以减少数据在网络上传输。在Spark中数据本地性优先级从高到底为PROCESS_LOCAL&gt;NONE_LOCAL&gt;NO_PREF&gt;RACK_LOCAL&gt;ANY,即最好的是任务运行的节点内存中存在数据、次好的是同一个Node（同一机器）上的，再次是同机架上，最后是任意位置。其中任务数据本地性通过以上情况来确定：</p>
<ul>
<li>如果任务处于作业开始的调度阶段内，这些任务对应的RDD分区都有首选运行位置，该位置也是任务运行首选位置，数据本地性为NODE_LOCAL。</li>
<li>如果任务处于非作业开头的调度阶段，可以根据父调度阶段运行的位置得到任务的首选位置，这种情况下，如果Executor处于活动状态，则数据本地性为PROCESS_LOCAL;如果Executor不处于活动状态，但存在父调度阶段运行结果，则数据本地性为NODE_LOCAL。</li>
<li>如果没有首选位置，则数据本地性为NO_PREF。</li>
</ul>
<p><strong>延迟执行</strong></p>
<p>在任务分配运行节点时，先判断任务最佳运行节点是否空闲，如果该节点没有足够的资源运行该任务，在这种情况下任务会等待一定时间；如果在等待内该节点释放出足够的资源，则任务在该节点运行，如果还是不足会找出次佳的节点进行运行。通过这样的方式进行能地让任务运行在更高级别数据本地性的节点，从而减少磁盘I/O和网络传输。一般来说只对PROCESS_LOCAL和NODE_LOCAL两个数据本地级别进行等待。</p>
<p>Spark任务分配的原则就是让任务运行在数据本地性优先级高的节点上，甚至可以为此等待一定的时间。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://codingsu.github.io/2018/03/25/Spark-study-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sujunwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sjw_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/25/Spark-study-4/" itemprop="url">Spark学习笔记(4) —— 作业执行原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-25T14:05:08+08:00">
                2018-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spark/" itemprop="url" rel="index">
                    <span itemprop="name">spark</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spark学习笔记-4-——-作业执行原理"><a href="#Spark学习笔记-4-——-作业执行原理" class="headerlink" title="Spark学习笔记(4) —— 作业执行原理"></a>Spark学习笔记(4) —— 作业执行原理</h1><p>Spark的作业和任务调度系统是其核心，它能够有效地进行调度是因为对任务的DAG划分和容错，是的它对低层到顶层的各个模块之间的调度和处理都显得游刃有余。</p>
<ul>
<li><strong>作业(job)</strong>: RDD中由行动操作所生成的一个或多个调度阶段。</li>
<li><strong>调度阶段(stage)</strong>: 每个作业会因为RDD之间的依赖关系拆分成多组任务集合，称为调度阶段，也叫任务集(TaskSet)。调度阶段的划分是由DAGScheduler来划分的。调度阶段有Shuffle Map Stage和Result Stage两种</li>
<li><strong>任务(task)</strong>: 分发到Executor上的工作任务，是Spark实际执行应用的最小单元。</li>
<li><strong>DAGScheduler</strong>: DAGScheduler是面向调度阶段的任务调度器，负责接收Spark应用提交的作业，根据RDD的依赖关系划分调度阶段，并提交调度阶段给TaskCheduler。</li>
<li><strong>TaskScheduler</strong>: TaskScheduler是面向任务的调度器，它接收DagScheduler提交过来的调度阶段，然后以把任务分发到Work节点运行，由Worker节点的Executor来运行任务。</li>
</ul>
<p>Spark的作业调度主要是指基于RDD的一系列操作构成一个作业，然后在Executor中执行。这些操作算子主要分为转换操作和行动操作，对于转换操作的计算是lazy级别的，也就是延迟执行，只有出现了行动操作才出发了作业的提交。在Spark调度中最重要的是DAGScheduler和TaskScheduler两个调度器，其中，DAGSscheduler负责任务的逻辑调度。将作业拆分成不同阶段的具有依赖关系的任务集，而TaskCheduler则负责具体任务的调度执行。</p>
<p><img src="spark1.png" alt="spark1"></p>
<ol>
<li>Spark应用程序进行各种转换操作，通过行动操作触发作业运行。提交之后根据RDD之间的依赖关系构建DAG图，DAG图提交给DAGScheduler进行解析。</li>
<li>DAGScheduler是面向调度阶段的高层次的调度器，DAGScheduler把DAG拆分成相互依赖的调度阶段，拆分调度阶段是以RDD的依赖是否为宽依赖，当遇到宽依赖就划分为新的调度阶段。每个调度阶段包含一个或多个任务，这些任务形成任务集，提交给底层调度器TaskCheduer进行调度运行。另外，DAGScheduler记录哪些RDD被存入磁盘等物化动作，同时要寻求任务的最优化调度，例如数据本地星等；DAGScheduler监控运行调度阶段过程，如果某个调度阶段运行失败，则需要重新提交该调度阶段。</li>
<li>每个TaskScheduler只为一个SparkContext实例服务，TaskScheduler接收来自DAGScheduler发送过来的任务集，TaskSchduler收到任务集后负责把任务集以任务的形式一个个分发到集群Worker节点的Executor中去运行。如果某个任务运行失败，TaskScheduler要负责重试。另外，如果TaskScheduler发现某个任务一直未运行完，就可能启动同样的任务运行同一个任务，哪一个任务先运行完就用哪个任务的结果。</li>
<li>Worker中的Executor收到TaskScheduler发送过来的任务后，以多线程的方式运行，每一个线程负责一个任务。任务运行结束后要返回给TaskScheduler，不同类型的任务，返回的方式也不同。ShuffleMapTask返回的是一个MapStatus对象，而不是结果本身;ResultTask根据结果大小的不同，返回的方式又可以分为两类。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://codingsu.github.io/2018/03/25/Spark-study-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sujunwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sjw_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/25/Spark-study-3/" itemprop="url">Spark学习笔记(3) —— 消息通信原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-25T11:30:26+08:00">
                2018-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spark/" itemprop="url" rel="index">
                    <span itemprop="name">spark</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spark学习笔记-3-——-消息通信原理"><a href="#Spark学习笔记-3-——-消息通信原理" class="headerlink" title="Spark学习笔记(3) —— 消息通信原理"></a>Spark学习笔记(3) —— 消息通信原理</h1><h4 id="Spark-消息通信架构"><a href="#Spark-消息通信架构" class="headerlink" title="Spark 消息通信架构"></a>Spark 消息通信架构</h4><p>Spark定义了通信框架接口，这些接口实现中调用Netty的具体方法。通信框架使用了工厂设计模式实现，这种设计方式实现了对Netty的解耦，能够根据需要引入其他的消息通信工具。</p>
<p><img src="spark1.png" alt="spark1"></p>
<h4 id="Spark-启动消息通信"><a href="#Spark-启动消息通信" class="headerlink" title="Spark 启动消息通信"></a>Spark 启动消息通信</h4><p>Spark启动过程中主要是进行Master与Worker之间的通信，首先由Worker节点想Master发送注册消息，然后Master处理完毕后，返回注册成功消息或失败消息，如果成功注册，则Worker定时发送心跳消息给Master。</p>
<p><img src="spark2.png" alt="spark2"></p>
<p>详细过程：</p>
<ol>
<li><p>当Master启动后，随之启动个Worker,Worker启动是会创建消息通信环境RpcEnv和终端点EndPoint，并向Master发送注册Worker的消息RegisterWorker。</p>
<p> 由于Worker可能需要注册到多个Master中，在Worker的tryRegisterAllMasters方法中创建注册线程池registerMasterThreadPool，把需要申请注册的请求放在该线程池中，然后通过该线程池启动注册线程。在该注册过程中，获取Master终端店引用，截止调用RegisterWithMaster方法，根据master终端店引用的send方法发送注册RegisterWorker消息。</p>
</li>
<li><p>Master收到消息后，需要对Worker发送的消息进行验证，记录。如果注册成功，则发送RegisteredWorker消息给对应的Worker，告诉他已经完成注册，随之进行步骤3，Worker定期发送心跳信息给Master；如果注册失败，则发送registerWorkerFailed消息。</p>
<p> 在Master中，Master接到注册消息后，先判断Master当前状态是否是standby，如果是则忽略注册消息。如果在注册列表中发现该Worker的编号，则返回重复注册的失败消息，如果没有问题，则使用registerWorker方法把该Worker加入到列表中。</p>
</li>
</ol>
<h4 id="Spark-运行时消息通信"><a href="#Spark-运行时消息通信" class="headerlink" title="Spark 运行时消息通信"></a>Spark 运行时消息通信</h4><p><img src="spark3.png" alt="spark3"></p>
<p>用户提交应用程序时，应用程序的SparkContext会向Master发送应用注册消息。</p>
<p>Master接收到注册应用信息后，Master将该应用放入应用列表中，并返回RegisteredApplication消息给应用程序。</p>
<p>同时Master在Worker列表中选取运行应用的Worker，发送LaunchExecutor消息给Worker，通知Worker启动Executor。</p>
<p>Executor启动成功后，Worker返回ExecutorStateChanged消息给Master，通知Executor容器已经创建完毕。</p>
<p>同时Executor会向SparkContext发送注册成功消息。</p>
<p>当SparkContext的RDD出发行动操作后，将创建RDD的DAG，通过DAGScheduler进行划分Stage，并将Stage转化为TaskSe。</p>
<p>接着有TaskScheduler向注册的Executor发送执行消息，Executor接收到任务消息后启动并运行。</p>
<p>最后当所有任务运行时，有Driver处理结果并回收资源。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://codingsu.github.io/2018/03/23/Spark-study-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sujunwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sjw_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/23/Spark-study-2/" itemprop="url">Spark学习笔记(2) —— spark RDD</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-23T11:07:09+08:00">
                2018-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spark/" itemprop="url" rel="index">
                    <span itemprop="name">spark</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spark学习笔记-2-——-Spark-RDD"><a href="#Spark学习笔记-2-——-Spark-RDD" class="headerlink" title="Spark学习笔记(2) —— Spark RDD"></a>Spark学习笔记(2) —— Spark RDD</h1><h4 id="Spark-RDD"><a href="#Spark-RDD" class="headerlink" title="Spark RDD"></a>Spark RDD</h4><p>四类操作</p>
<ul>
<li>创建操作： 用于RDD创建工作，RDD创建只有两种方法，中是来自于内存集合和外部存储系统，另一种是通过转换操作生成的RDD</li>
<li>转换操作：将RDD通过一定的操作变换成新的RDD，比如HadoopRDD可以使用map操作变换为MappedRDD，RDD的转换操作是惰性操作。</li>
<li>控制操作：进行RDD出九华，可以让RDD按不同的存储侧率保存在磁盘和内存中，比如cache接口默认将RDD缓存在内存中。</li>
<li>行动操作：能够出发Spark运行的操作，李璐，对RDD进行collect就是行动操作。Spark中行动操作。</li>
</ul>
<h4 id="RDD的实现"><a href="#RDD的实现" class="headerlink" title="RDD的实现"></a>RDD的实现</h4><ul>
<li>作业调度</li>
</ul>
<p>当对RDD执行转换操作是，调度器会根据RDD的血统来构建有若干调度阶段组成的有向无环图，每个调度阶段包含尽可能多的连续窄依赖转换。调度器按照有向无环图顺序进行计算，并最总得到目标RDD。</p>
<ul>
<li>解析器集成</li>
</ul>
<p>Scala</p>
<ul>
<li>内存管理</li>
</ul>
<p>Spark 提供了3中持久化RDD的存储策略：未序列化Java对象存在内存中、序列化的数据存于内存中已经存储在磁盘中。第一个选项的性能是最优的，因为可以直接访问在Java虚拟机内存里的RDD对象；在空间有限的情况下，第二种方式可以让用户采用比Java对象更有效的内存组织方式，但代价是降低了性能；第三种策略使用于RDD太大的情形，每次重新计算该RDD会带来额外的资源开销。</p>
<p>对于内存使用LRU回收算法进行管理，当计算得到一个新的RDD分区，但没有足够的空间来存储时，系统会从最近最少使用的RDD中回收一个分区的空间，除非新加的RDD分区是这个RDD对应的分区，在这种情况下则会保留这个最少使用的RDD，避免多次调入调出数据。</p>
<ul>
<li>检查点支持</li>
</ul>
<p>尽管血统可以用于错误后RDD的恢复，但是对于很长的血统的RDD来说，这样的恢复耗时较长，所以需要通过检查点操作保存到外部存储中。</p>
<ul>
<li>多用户管理</li>
</ul>
<p>RDD模型将计算分解为多个相互独立的细粒度任务，这使得它在多用户集群能够支持多种资源共享算法。</p>
<ul>
<li>RDD依赖关系</li>
</ul>
<p>RDD中将依赖划分成了两种类型：窄依赖和宽依赖。</p>
<pre><code>窄依赖是指每个父RDD的分区都之多被一个子RDD的分区使用（一对一）， 宽依赖是多个子RDD的分区依赖一个父RDD的分区（多对一）
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://codingsu.github.io/2018/03/22/Spark-study(1)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sujunwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sjw_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/22/Spark-study(1)/" itemprop="url">Spark学习笔记(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-22T11:04:55+08:00">
                2018-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spark/" itemprop="url" rel="index">
                    <span itemprop="name">spark</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Spark学习笔记-1"><a href="#Spark学习笔记-1" class="headerlink" title="Spark学习笔记(1)"></a>Spark学习笔记(1)</h1><h4 id="Spark-和-Hadoop-速度优势对比"><a href="#Spark-和-Hadoop-速度优势对比" class="headerlink" title="Spark 和 Hadoop 速度优势对比"></a>Spark 和 Hadoop 速度优势对比</h4><ol>
<li>Spark 默认情况下的迭代过程的数据保存到内存中，后续的运行作业利用这些结果进行计算，而Hadoop每次计算结果都直接存储到磁盘中。</li>
<li>由于较复杂的数据计算任务需要多个步骤才能实现，且步骤之间具有依赖性。Hadoop需要借助Oozie等工具今夕处理。而Spark在执行任务之前，可以将这些步骤依赖关系形成DAG图（有向无环图），任务可以按图索骥，从而优化了计算路径。</li>
</ol>
<h4 id="Spark的生态圈"><a href="#Spark的生态圈" class="headerlink" title="Spark的生态圈"></a>Spark的生态圈</h4><ul>
<li>Spark Core 提供内存计算框架</li>
<li>Spark streaminging的实时处理应用</li>
<li>Spark SQL的即席查询</li>
<li>MLlib的机器学习</li>
<li>GraphX的图处理</li>
</ul>
<p><img src="/spark技术堆栈.png" alt="spark技术堆栈"></p>
<h4 id="Spark与MapReduce比较"><a href="#Spark与MapReduce比较" class="headerlink" title="Spark与MapReduce比较"></a>Spark与MapReduce比较</h4><ol>
<li><p>Spark 把中间数据存储放在内存中，迭代运算效率高，MapReduce则是放在磁盘上，而Spark支持DAG图的分布式并行计算的编程框架</p>
</li>
<li><p>Spark的容错性高，Spark引进了弹性分布式数据集(Resilient DIstributed Dataset,RDD)的概念，他是分布在一组节点中的只读对象集合，这些集合是弹性的，如果数据集一部分丢失，则可以根据“血统”（即允许基于数据衍生过程）对他们重建。另外在RDD计算时可以通过CheckPoint来实现容错。CheckPoint有两种方式，即CheckPoint Data和Logging The Update。</p>
</li>
<li><p>Spark更加通用。Hadoop只提供了Map和Reduce两种操作，Spark提供的数据集操作类型有很多种，大致分为转换操作和行动操作两大类。转换操作包括Map，Filter，FlatMap，Sample，GroupByKey，ReduceBykey，Union，Join，Cogroup，MapValues，Sort和PartionBy等多种操作类型，行动操作包括Collect，Reduce，Lookup和Save等操作类型。另外，各个处理节点之间的通信模型不再像Hadoop只有Shuffle一种模式，用户可以命名，物化，控制中间结果的存储，分区等。</p>
</li>
</ol>
<h4 id="Spark-core"><a href="#Spark-core" class="headerlink" title="Spark core"></a>Spark core</h4><p>连接Spark各种生态的核心<br><img src="/sparkcore.png" alt="sparkcore"></p>
<h4 id="Spark-streaming"><a href="#Spark-streaming" class="headerlink" title="Spark streaming"></a>Spark streaming</h4><p>Spark streaminging是一个对实时数据流进行高吞吐，高容错的六室处理系统，可以对多种数据源进行类似Map,Reduce和Join等复杂操作，并将结果保存到外部文件系统，数据库。相比其他的处理引擎要么只专注于流处理，要么只负责批处理，而Spark streaming最大的优势是听的处理引擎和RDD编程模型可以同时进行批处理于流处理。<br></p>
<p>对于传统流处理中一次处理一条记录的方式而言，Spark streaming使用的是将流数据离散化处理(Discretized streamings)，通过该吹方式能够进行秒级以下的数据批处理。在Spark streaming处理过程中，Receiver并行接收数据，并将数据缓存至Spark工作节点的内存中。经过延迟优化后，Spark引擎对段任务能够进行批处理，并且可将结果暑促至其他系统中。</p>
<p><img src="/sparksteam.png" alt="sparksteam"></p>
<p>使用离散化流数据，Spark streaming将具有：</p>
<ol>
<li><p>动态负载均衡：<br>通过将数据划分为小批量，通过这种方式可以实现对资源更细粒度的分配。在传统实时流记录处理系统在输入数据流以键值进行分区处理情况下，如果一个节点计算压力较大超出了符合，会拖慢整个系统的处理速度。而Spark streaming会将作业任务动态平衡的分给各个几点。</p>
</li>
<li><p>快速故障恢复机制：<br>在节点出现故障的情况下，传统流处理系统会在其他的节点上重启失败的连续算子，并可能重新运行先前数据流处理操作获取部分丢失数据。需要等新节点完成故障前的所有计算后整个系统才能够处理其他任务。在Spark中，计算分成多个小任务，保证任何节点运行后能够正确进行合并，在某个节点出现故障的情况，这个节点的任务将均匀的分散到集群中的节点进行计算，比单个节点计算能够更快的恢复数据。</p>
</li>
<li><p>批处理、流处理与交互式分析的一体化：<br>Spark streaming把流式计算分解成一系列小的的批处理作业，也就是一段段离散数据流，每一段数据都转换成Spark中的RDD，然后将Spark streaming中对离散数据流处理操作变成对RDD的批处理操作。</p>
</li>
</ol>
<h4 id="Spark-SQL"><a href="#Spark-SQL" class="headerlink" title="Spark SQL"></a>Spark SQL</h4><p>特点：</p>
<ul>
<li>引入了新的RDD类型SchemaRDD，可以向传统数据库定义表一样来定义SChemaRDD，SchemaRDD由定义了列数据类型的行对象构成。SchemaRDD既可以从RDD转换过来，也可以从Parquet文件读入，还可以使用HiveQL从Hive中获取。</li>
<li>内嵌了Catalyst查询优化框架，在吧Sql解析成逻辑执行计划之后，利用Catalyst包里一些类和接口，执行了一些简单的执行计划优化，最后变成RDD的计算。</li>
<li>在应用程序中可以混合使用不同来源的数据，如可以将来字HiveQl的数据和来自SQL的数据进行Jion操作。 </li>
</ul>
<p>Spark SQL性能优化：</p>
<ul>
<li>内存列存储：表数据在内存汇总存储不是采用原生态的JVM对象存储方式，而是采用内存列存储</li>
<li>字节码生成技术：在Catalyst模块的Expressions增加了Codegen模块，使用动态字节码生成技术，对匹配的表达式采用特定的代码动态编译。另外对SQL表达式都做了CG优化。CG优化的实现主要还是依靠Scala运行的反射机制</li>
</ul>
<h4 id="MLBase-MLlib"><a href="#MLBase-MLlib" class="headerlink" title="MLBase/MLlib"></a>MLBase/MLlib</h4><p>MLBase分为4个部分：</p>
<ul>
<li>MLRuntime:是由Spark Core提供的分布式内存计算框架，运行有Optimizer优化过的算法进行数据的计算并输出分析结果。</li>
<li>MLlib:是Spark实现一些常见的机器学习算法和使用程序。</li>
<li>MLI：s是一个特征抽取和高级ML编程抽象算法实现的API或平台。</li>
<li>ML Optimizer:会选择最合适的已经在内部实现好了的机器学习算法和相关参数来处理用户输入的数据。</li>
</ul>
<h4 id="GraphX"><a href="#GraphX" class="headerlink" title="GraphX"></a>GraphX</h4><p>GraphX的核心抽象是Resilient Distributed Property Graph，一种电荷变都带属性的有向多重图。GraphX扩展了SparkRDD的抽象，他有Table和Graph两种视图，但只需要一份物理存储，两种视图都有自己独有的操作符，从而获得了灵活操作和执行效率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://codingsu.github.io/2018/03/16/Search-for-a-Range/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sujunwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sjw_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/16/Search-for-a-Range/" itemprop="url">Search for a Range</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-16T10:08:40+08:00">
                2018-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Leetcode-Search-for-a-Range"><a href="#Leetcode-Search-for-a-Range" class="headerlink" title="[Leetcode] Search for a Range"></a>[Leetcode] Search for a Range</h1><p>Given an array of integers sorted in ascending order, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>If the target is not found in the array, return [-1, -1].</p>
<p>For example,<br>Given [5, 7, 7, 8, 8, 10] and target value 8,<br>return [3, 4].</p>
<p><strong>解题思路：</strong><br>该题要求时间复杂度要在O(logn)内，所以使用折半查找法，在查找到对应的位置后，需要在该位置前后去查找相同的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> nums == <span class="keyword">None</span> <span class="keyword">or</span> len(nums) == <span class="number">0</span> <span class="keyword">or</span> target &lt; nums[<span class="number">0</span>] <span class="keyword">or</span> target &gt; nums[<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(l, r, nums, target)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, l, r, nums, target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l &lt;= r:</span><br><span class="line">            m = (l + r)/<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == target:</span><br><span class="line">                i1 = m</span><br><span class="line">                i2 = m</span><br><span class="line">                <span class="keyword">while</span>(i1<span class="number">-1</span> &gt;=l <span class="keyword">and</span> nums[i1<span class="number">-1</span>] == target):</span><br><span class="line">                    i1 -=<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span>(i2+<span class="number">1</span> &lt;len(nums) <span class="keyword">and</span> nums[i2+<span class="number">1</span>] == target):</span><br><span class="line">                    i2 +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> [i1,i2]</span><br><span class="line">            <span class="keyword">elif</span> nums[m] &gt; target:</span><br><span class="line">                <span class="keyword">return</span> self.helper(l, m<span class="number">-1</span>, nums, target)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.helper(m+<span class="number">1</span>, r, nums, target)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://codingsu.github.io/2018/03/16/Search-in-Rotated-Sorted-Array/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="sujunwei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="sjw_blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/16/Search-in-Rotated-Sorted-Array/" itemprop="url">Search in Rotated Sorted Array</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-16T09:43:56+08:00">
                2018-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">Leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Leetcode-Search-in-Rotated-Sorted-Array"><a href="#Leetcode-Search-in-Rotated-Sorted-Array" class="headerlink" title="[Leetcode] Search in Rotated Sorted Array"></a>[Leetcode] Search in Rotated Sorted Array</h1><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<p><strong>解题思路：</strong><br>判断目标数字和数组头尾的大小比较，然后根据比较结果，进行遍历，同时添加遍历退出的判断。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> nums == <span class="keyword">None</span> <span class="keyword">or</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] &lt;= target:</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> target &lt; nums[n]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">                <span class="keyword">if</span> target == nums[n]:</span><br><span class="line">                    <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">elif</span> nums[<span class="number">-1</span>] &gt;= target:</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> range(len(nums))[::<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">if</span> target &gt; nums[n]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">                <span class="keyword">if</span> target == nums[n]:</span><br><span class="line">                    <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">sujunwei</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">true</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
